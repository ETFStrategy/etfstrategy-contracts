// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test, console} from "forge-std/Test.sol";
import {Treasury} from "../src/Treasury.sol";
import {MockERC20} from "../src/MockERC20.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

// Uniswap V3 interfaces for liquidity
interface INonfungiblePositionManager {
    struct MintParams {
        address token0;
        address token1;
        uint24 fee;
        int24 tickLower;
        int24 tickUpper;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        address recipient;
        uint256 deadline;
    }
    
    function mint(MintParams calldata params) external payable returns (
        uint256 tokenId,
        uint128 liquidity,
        uint256 amount0,
        uint256 amount1
    );
}

interface IUniswapV3Factory {
    function createPool(address tokenA, address tokenB, uint24 fee) external returns (address pool);
    function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address);
}

contract TreasuryTest is Test {
    Treasury public treasury;
    MockERC20 public mockToken; // buyBackToken
    
    // Real Mainnet addresses
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant WSOL = 0xD31a59c85aE9D8edEFeC411D448f90841571b89c; // target token
    address constant UNISWAP_V3_FACTORY = 0x1F98431c8aD98523631AE4a59f267346ea31F984;
    address constant NONFUNGIBLE_POSITION_MANAGER = 0xC36442b4a4522E871399CD717aBDD847Ab11FE88;
    
    // Test parameters
    address owner = makeAddr("owner");
    address user1 = makeAddr("user1");
    address user2 = makeAddr("user2");
    address liquidityProvider = makeAddr("liquidityProvider");
    
    uint256 constant AMOUNT_PER_ORDER = 1000 * 1e18; // 1000 WSOL (18 decimals)
    uint256 constant MIN_PNL_PERCENT = 5; // 5% minimum profit
    uint24 constant POOL_FEE = 3000; // 0.3%
    uint256 constant CALLER_REWARD = 0.001 ether; // 0.001 ETH
    
    function setUp() public {
        console.log("=== Treasury Test Setup with WSOL and MockERC20 ===");
        
        // Fork Mainnet at a recent block
        string memory rpcUrl = vm.envOr("ETH_RPC_URL", string("https://eth-mainnet.alchemyapi.io/v2/demo"));
        vm.createSelectFork(rpcUrl);
        
        // Deploy MockERC20 as buyBackToken
        vm.startPrank(owner);
        mockToken = new MockERC20();
        vm.stopPrank();
        
        console.log("MockERC20 deployed at:", address(mockToken));
        console.log("MockERC20 total supply:", mockToken.totalSupply() / 1e18, "tokens");
        
        // Setup liquidity for WSOL/WETH and MockToken/WETH pools
        _setupLiquidity();
        
        // Deploy Treasury with configuration
        vm.startPrank(owner);
        treasury = new Treasury(
            owner,
            WSOL,           // target token
            AMOUNT_PER_ORDER,
            MIN_PNL_PERCENT,
            address(mockToken), // buyback token
            POOL_FEE,
            CALLER_REWARD
        );
        vm.stopPrank();
        
        // Fund treasury with ETH for testing
        vm.deal(address(treasury), 50 ether);
        
        // Fund users with ETH for gas
        vm.deal(user1, 1 ether);
        vm.deal(user2, 1 ether);
        
        console.log("Treasury deployed at:", address(treasury));
        console.log("Treasury ETH balance:", address(treasury).balance / 1e18, "ETH");
        console.log("Target token (WSOL):", WSOL);
        console.log("Buyback token (MockERC20):", address(mockToken));
        console.log("Amount per order:", AMOUNT_PER_ORDER / 1e18, "WSOL");
    }
    
    function testBuy() public {
        console.log("\\n=== Testing Buy Function ===");
        
        // Get initial state
        uint256 initialTreasuryBalance = address(treasury).balance;
        uint256 initialUser1Balance = user1.balance;
        
        // Check if can buy
        (bool canBuyNow, uint256 requiredETH) = treasury.canBuy();
        
        console.log("Can buy:", canBuyNow);
        console.log("Required ETH:", requiredETH / 1e18, "ETH");
        
        // Skip test if cannot get quote (might happen on fork)
        if (!canBuyNow) {
            console.log("⚠️  Skipping buy test - insufficient liquidity or quote failed");
            return;
        }
        
        // Execute buy as user1
        vm.startPrank(user1);
        
        // Record pre-buy state
        uint256 preOrderId = treasury.currentOrderId();
        console.log("Current order ID before buy:", preOrderId);
        
        // Execute buy
        treasury.buy();
        
        vm.stopPrank();
        
        // Verify results
        uint256 finalTreasuryBalance = address(treasury).balance;
        uint256 finalUser1Balance = user1.balance;
        uint256 currentOrderId = treasury.currentOrderId();
        
        // Check that order was created
        assertEq(currentOrderId, preOrderId + 1, "Order ID should increment");
        
        // Check that user received caller reward
        assertTrue(
            finalUser1Balance >= initialUser1Balance + CALLER_REWARD - 100000, // Allow for gas costs
            "User should receive caller reward (minus gas)"
        );
        
        // Check that treasury balance decreased
        assertLt(
            finalTreasuryBalance,
            initialTreasuryBalance - CALLER_REWARD,
            "Treasury should spend ETH on tokens plus caller reward"
        );
        
        // Get order details
        Treasury.Order memory order = treasury.getOrder(preOrderId);
        
        // Verify order details
        assertEq(order.id, preOrderId, "Order ID should match");
        assertEq(order.token, USDC, "Order token should be USDC");
        assertEq(order.tokenAmount, AMOUNT_PER_ORDER, "Order amount should match");
        assertGt(order.ethSpent, 0, "ETH spent should be greater than 0");
        assertGt(order.buyPrice, 0, "Buy price should be greater than 0");
        assertTrue(order.status == Treasury.OrderStatus.SELLING, "Order should be in SELLING status");
        
        console.log("✅ Buy test completed successfully");
        console.log("Order ID:", order.id);
        console.log("ETH spent:", order.ethSpent / 1e18, "ETH");
        console.log("Buy price:", order.buyPrice);
        console.log("Target sell price:", order.targetSellPrice);
        
        // Check if treasury received USDC tokens
        uint256 usdcBalance = IERC20(USDC).balanceOf(address(treasury));
        console.log("Treasury USDC balance after buy:", usdcBalance / 1e6, "USDC");
    }
    
    function testSell() public {
        console.log("\\n=== Testing Sell Function ===");
        
        // First execute a buy to have an order to sell
        vm.startPrank(user1);
        
        // Check if can buy first
        (bool canBuyNow,) = treasury.canBuy();
        
        if (!canBuyNow) {
            console.log("⚠️  Skipping sell test - cannot execute initial buy");
            return;
        }
        
        // Execute buy
        uint256 orderIdToSell = treasury.currentOrderId();
        treasury.buy();
        vm.stopPrank();
        
        console.log("Buy executed, order ID:", orderIdToSell);
        
        // Get the created order
        Treasury.Order memory orderBeforeSell = treasury.getOrder(orderIdToSell);
        
        // Verify order is in SELLING status
        assertTrue(
            orderBeforeSell.status == Treasury.OrderStatus.SELLING,
            "Order should be in SELLING status before sell"
        );
        
        console.log("Order status before sell:", uint(orderBeforeSell.status));
        console.log("Order ETH spent:", orderBeforeSell.ethSpent / 1e18, "ETH");
        console.log("Order token amount:", orderBeforeSell.tokenAmount / 1e6, "USDC");
        
        // Check treasury token balance
        uint256 treasuryTokenBalance = IERC20(USDC).balanceOf(address(treasury));
        console.log("Treasury USDC balance before sell:", treasuryTokenBalance / 1e6, "USDC");
        
        // If treasury doesn't have enough tokens, skip sell test
        if (treasuryTokenBalance < AMOUNT_PER_ORDER) {
            console.log("⚠️  Skipping sell test - treasury doesn't have enough tokens");
            return;
        }
        
        // Record initial balances
        uint256 initialUser2Balance = user2.balance;
        uint256 initialTreasuryETHBalance = address(treasury).balance;
        
        // Execute sell as user2
        vm.startPrank(user2);
        
        console.log("Executing sell...");
        treasury.sell(orderIdToSell);
        
        vm.stopPrank();
        
        // Verify results
        uint256 finalUser2Balance = user2.balance;
        Treasury.Order memory orderAfterSell = treasury.getOrder(orderIdToSell);
        
        // Check that order status changed to SUCCESS
        assertTrue(
            orderAfterSell.status == Treasury.OrderStatus.SUCCESS,
            "Order should be in SUCCESS status after sell"
        );
        
        // Check that sell timestamp was set
        assertGt(orderAfterSell.sellTimestamp, 0, "Sell timestamp should be set");
        
        console.log("✅ Sell test completed successfully");
        console.log("Order ID:", orderAfterSell.id);
        console.log("Sell timestamp:", orderAfterSell.sellTimestamp);
        console.log("Order status after sell:", uint(orderAfterSell.status));
        
        // Check caller reward
        if (finalUser2Balance > initialUser2Balance) {
            console.log("User2 received caller reward:", (finalUser2Balance - initialUser2Balance) / 1e18, "ETH");
        } else {
            console.log("No caller reward received (may be due to gas costs or insufficient profit)");
        }
        
        // Check final treasury token balance
        uint256 finalTreasuryTokenBalance = IERC20(USDC).balanceOf(address(treasury));
        console.log("Treasury USDC balance after sell:", finalTreasuryTokenBalance / 1e6, "USDC");
    }
    
    function testBuyAndSellSequence() public {
        console.log("\\n=== Testing Complete Buy and Sell Sequence ===");
        
        // Record initial state
        uint256 initialTreasuryBalance = address(treasury).balance;
        console.log("Initial treasury balance:", initialTreasuryBalance / 1e18, "ETH");
        
        // Execute buy
        vm.startPrank(user1);
        
        (bool canBuyNow,) = treasury.canBuy();
        if (!canBuyNow) {
            console.log("⚠️  Skipping sequence test - cannot buy");
            return;
        }
        
        uint256 orderIdToTest = treasury.currentOrderId();
        console.log("Creating order ID:", orderIdToTest);
        
        treasury.buy();
        vm.stopPrank();
        
        // Check intermediate state
        Treasury.Order memory orderAfterBuy = treasury.getOrder(orderIdToTest);
        console.log("After buy - Order status:", uint(orderAfterBuy.status));
        console.log("After buy - ETH spent:", orderAfterBuy.ethSpent / 1e18, "ETH");
        
        // Check if treasury has tokens
        uint256 tokenBalance = IERC20(USDC).balanceOf(address(treasury));
        console.log("Treasury token balance after buy:", tokenBalance / 1e6, "USDC");
        
        if (tokenBalance < AMOUNT_PER_ORDER) {
            console.log("⚠️  Insufficient tokens for sell, skipping sell part");
            return;
        }
        
        // Execute sell
        vm.startPrank(user2);
        treasury.sell(orderIdToTest);
        vm.stopPrank();
        
        // Check final state
        Treasury.Order memory orderAfterSell = treasury.getOrder(orderIdToTest);
        uint256 finalTreasuryBalance = address(treasury).balance;
        
        console.log("After sell - Order status:", uint(orderAfterSell.status));
        console.log("Final treasury balance:", finalTreasuryBalance / 1e18, "ETH");
        console.log("Treasury balance change:", int256(finalTreasuryBalance) - int256(initialTreasuryBalance), "wei");
        
        // Verify complete cycle
        assertTrue(
            orderAfterSell.status == Treasury.OrderStatus.SUCCESS,
            "Order should be completed"
        );
        
        assertGt(orderAfterSell.sellTimestamp, orderAfterBuy.buyTimestamp, "Sell should be after buy");
        
        console.log("✅ Buy and sell sequence completed successfully");
        console.log("Order lifecycle: BUYING -> SELLING -> SUCCESS");
    }
    
    function testMainnetIntegration() public {
        console.log("\\n=== Testing Mainnet Integration ===");
        
        // Test real addresses
        console.log("WETH address:", WETH);
        console.log("USDC address:", USDC);
        console.log("DAI address:", DAI);
        
        // Check if contracts exist on this fork
        uint256 wethCodeSize;
        uint256 usdcCodeSize;
        assembly {
            wethCodeSize := extcodesize(WETH)
            usdcCodeSize := extcodesize(USDC)
        }
        
        console.log("WETH contract size:", wethCodeSize);
        console.log("USDC contract size:", usdcCodeSize);
        
        if (wethCodeSize == 0 || usdcCodeSize == 0) {
            console.log("⚠️  Contract addresses not found on this fork");
            return;
        }
        
        // Test treasury configuration
        (
            address token,
            uint256 amount,
            uint256 minPnl,
            address buyBack,
            uint24 fee,
            uint256 reward
        ) = treasury.getConfig();
        
        console.log("Treasury configuration:");
        console.log("  Target token:", token);
        console.log("  Amount per order:", amount / 1e6, "USDC");
        console.log("  Min PNL:", minPnl, "%");
        console.log("  Buyback token:", buyBack);
        console.log("  Pool fee:", fee);
        console.log("  Caller reward:", reward / 1e18, "ETH");
        
        assertTrue(token == USDC, "Target token should be USDC");
        assertTrue(buyBack == DAI, "Buyback token should be DAI");
        
        console.log("✅ Mainnet integration test passed");
    }
    
    function testGetConfig() public view {
        (
            address token,
            uint256 amount,
            uint256 minPnl,
            address buyBack,
            uint24 fee,
            uint256 reward
        ) = treasury.getConfig();
        
        assertEq(token, USDC, "Target token should be USDC");
        assertEq(amount, AMOUNT_PER_ORDER, "Amount per order should match");
        assertEq(minPnl, MIN_PNL_PERCENT, "Min PNL should match");
        assertEq(buyBack, BUYBACK_TOKEN, "Buyback token should match");
        assertEq(fee, POOL_FEE, "Pool fee should match");
        assertEq(reward, CALLER_REWARD, "Caller reward should match");
        
        console.log("Configuration verified successfully");
    }
    
    function testGetBalances() public view {
        (uint256 ethBalance, uint256 tokenBalance) = treasury.getBalances();
        
        assertEq(ethBalance, address(treasury).balance, "ETH balance should match");
        
        console.log("ETH balance:", ethBalance);
        console.log("Token balance:", tokenBalance);
    }
}